#!/bin/bash -e

# A note about efivarfs is in order. The efivarfs virtual filesystem offers
# easy access to EFI variables. The format is four bytes of attribute flags
# followed by the variable value. When reading, we skip the four-byte header.
# When writing, we hard-code the header.

UUID="6987e713-a5ff-4ec2-ad55-c1fca471ed2d"
NAME="CmdLine"
BASE="/sys/firmware/efi/efivars"

function cleanup() {
  reboot
}
trap cleanup EXIT

function readefi() {
  cat $BASE/$NAME-$UUID | tail -c +5
}

# Parse the kernel cmdline
cmdline=""
for arg in `cat /proc/cmdline`; do
  case "${arg}" in
    wyrcan.pass=*) cmdline="${cmdline} ${arg#wyrcan.pass=}";;
    wyrcan.efi=write) efi=write;;
    wyrcan.efi=clear) efi=clear;;
    wyrcan.img=*) slug="${arg#wyrcan.img=}";;
    wyrcan.*) ;; # Drop this argument
    initrd=*) ;; # Drop this argument
    *) cmdline="${cmdline} ${arg}";;
  esac
done

# Clear the EFI variable and shut down.
if [ "$efi" == clear ]; then
  echo "" >&2
  echo "⚠⚠⚠ WARNING ⚠⚠⚠" >&2
  echo "" >&2
  echo "On some buggy hardware, clearing an EFI variable can cause the" >&2
  echo "hardware to become unresponsive. Proceeding with this action" >&2
  echo "could cause irreversible damage to your hardware." >&2
  echo "" >&2
  echo "⚠⚠⚠ WARNING ⚠⚠⚠" >&2
  echo "" >&2
  read -p "Would you like to proceed? [yes/no] " answer

  if [ "$answer" == "yes" ] && [ -f $BASE/$NAME-$UUID ] ; then
    chattr -i $BASE/$NAME-$UUID
    rm -f $BASE/$NAME-$UUID
  fi

  exit 0
fi

# If not in the cmdline, look for an EFI variable.
if [ -z "$slug" ]; then
  if [ -f $BASE/$NAME-$UUID ]; then
    # Sanity check that we don't get binary data...
    if readefi | LC_ALL=C grep -q '[^[:print:]]'; then
      echo "Invalid $BASE/$NAME-$UUID!" >&2
    else
      cmdline=`readefi`
      echo "Loaded cmdline: ${cmdline}" >&2

      # Parse the stored cmdline
      cmdline=""
      for arg in `readefi`; do
        case "${arg}" in
          wyrcan.img=*) slug="${arg#wyrcan.img=}";;
          wyrcan.*) ;; # Drop this argument
          *) cmdline="${cmdline} ${arg}";;
        esac
      done
    fi
  fi
fi

# No actionable configuration was found.
if [ -z "$slug" ]; then
  echo "" >&2
  echo "No container image target could be found!" >&2
  echo "" >&2
  echo "Specify the container image to boot using the kernel cmdline." >&2
  echo "For example: wyrcan.img=docker.io/myuser/mycontainer" >&2
  echo "" >&2
  echo "NOTE: You can use wyrcan.efi=write to persist your cmdline" >&2
  echo "      across reboots. Or use wyrcan.efi=clear to clear an" >&2
  echo "      existing saved value. Be aware that some older EFI" >&2
  echo "      implementations have buggy support for custom EFI" >&2
  echo "      variables. Using wyrcan.efi=clear can brick them." >&2
  echo "" >&2
  read -n 1 -s -r -p "Press any key to reboot."
  exit 1
fi

# TODO: do strict sanity checking on the slug format...

# Download the container.
echo "Fetching $slug..." >&2
seconds=5
while ! buildah pull "$slug"; do
  sleep $seconds
  seconds=$(($seconds * 2))
done

# Extract the kernel and initrd
echo "Preparing to boot $slug..." >&2
wyrcan-extract --kernel /tmp/kernel --initrd /tmp/initrd --cmdline /tmp/cmdline "$slug"
extra=`cat /tmp/cmdline`

# Set the EFI variable.
if [ "$efi" == write ]; then
  echo "Saving \"${cmdline} wyrcan.img=${slug}\" to $NAME ($UUID)..." >&2
  printf "\\x07\\x00\\x00\\x00%s wyrcan.img=%s" "$cmdline" "$slug" > $BASE/$NAME-$UUID
  exit 0
fi

# Extract the kernel and initramfs and boot them.
echo "Booting $slug..." >&2
echo "cmdline: ${extra} ${cmdline}" >&2
exec kexec -fixy --initrd=/tmp/initrd --append="${extra} ${cmdline}" /tmp/kernel
